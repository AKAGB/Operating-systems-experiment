# 进程描述和控制

> 定义进程并解释进程与控制块之间的关系
> 理解进程状态和进程状态转换的过程
> 了解操作系统管理进程所用的数据结构，列出相关数据结构并解释其目的
> 评估操作系统对进程控制的需求
> 掌握操作系统代码运行时涉及的问题

## 1. 什么是进程

### 1.1 定义

**进程**有如下几个定义：

- 一个正在执行的程序。
- 一个正在计算机上执行的程序实例。
- 能分配给处理器并由处理器执行的实体。
- 由一组执行的指令、一个当前状态和一组相关的系统资源表征的活动单元。

进程的两个基本元素是**程序代码**和**数据集**。

### 1.2 进程控制块

进程执行的任意时刻，都可以用以下元素来表征：

- 标识符：与进程相关的唯一标识符，用来区分其他进程。
- 状态：进程有多种状态如运行态、就绪态等等。
- 优先级：相对于其他进程的优先顺序。
- 程序计数器：程序中即将执行的下一条指令的地址。
- 内存指针：包括程序代码和进程相关数据的指针，以及与其他进程共享内存块的指针。
- 上下文数据：进程执行时处理器的寄存器中的数据。
- I/O状态信息：包括显式I/O请求，分配给进程的I/O设备和被进程使用的文件列表。
- 记账信息：包括处理器时间总和、使用的时钟数总和、时间限制、记账号等。
- ...

上述列表信息放在**进程控制块**（process control block, PCB）的数据结构中。控制块由操作系统创建和管理。进程中断时，操作系统会把程序计数器和处理器寄存器（上下文数据）保存到进程控制块中的相应位置，进程状态相应的改为其它值。

因此可以说进程由程序代码和相关数据及进程控制块组成。

## 2. 进程状态

**轨迹**：列出进程执行的指令序列，可描述单个进程的行为，这样的序列称为进程轨迹。

**分配器**：也叫调度器，使处理器能够切换进程。

### 2.1 两状态进程模型

![two stage proc](images/two_stage_proc.png)

进程可处于以下两种状态之一：**运行态**或**未运行态**。

操作系统创建一个新进程时，它将以该进程以未运行态加入系统，操作系统知道这个进程的存在并等待执行机会。时不时地分配器会中断当前执行的进程，然后分配器会选择一个新进程执行。

未运行态进程必须位于某种类型的队列中，等待执行时机。

### 2.2 进程的创建和终止

#### 进程创建的原因

- 新的批处理作业
- 交互登录
- 为提供服务而由操作系统创建
- 由现有进程派生

#### 进程终止的原因

- 正常完成
- 超过时限
- 无可用内存
- 超出范围
- 保护错误
- 算数错误
- 时间超出
- I/O失败
- 无效指令
- 特权指令
- 数据误用
- 操作员或操作系统干涉
- 父进程终止
- 父进程请求

### 2.3 五状态模型

之前的两状态进程模型并不一定合适实际应用，因为它对队列中的进程不加以区分（全部归类为未运行态），如果从队列中取出某一个进程，它未必就能执行，因为它可能还在阻塞中（例如I/O还未准备完成）。解决的一个策略是将未运行态分为两个状态：**就绪态**和**阻塞态**，除此之外还添加两个被证明了很有用的状态，故出现了五状态模型：

![five stage proc](images/five_stage_proc.png)

- 运行态：进程正在执行。对于单CPU一次最多只有一个进程处于这个状态。
- 就绪态：进程做好了准备，只要有机会就开始执行。
- 阻塞态（等待态）：进程在某些事件发生前不能执行，如I/O操作完成。
- 新建态：刚刚创建的进程，操作系统还未把它加入可执行进程组，通常是进程控制块已经创建但未被加载到内存中的进程。
- 退出态：操作系统从可执行进程组中释放出的进程。

### 2.4 被挂起的进程

早期还没有虚拟内存的时候，我们内存空间有限，如果依照之前的五状态模型，可能会出现一种情况，队列中等待的进程越来越多，而这些在队列中的进程依旧要占据内存的空间，内存空间会逐渐被越来越多的进程占据完。

解决这种窘境的策略有两种：

1. 扩充内存。这种方案有两个缺点，一是内存的造价很高，而是对内存空间增长的需求快于内存价格下降的速度。
2. 交换，即将内存中的某个进程的一部分或全部移到外存中。当系统中不存在就绪态的进程时，操作系统就把被阻塞的进程移动到外存中的**挂起队列**中，也就是临时“踢出”等待队列。

上面提到的那种交换方案是**包含单挂起态的模型**，只是把阻塞态进程挂起，然而把被阻塞的内存取回内存没有任何意义，因为它仍未做好执行的准备。

![Single](images/single.png)

因此，将这是否在等待一个事件和是否被挂起分离开来，就出现了4种状态：

- 就绪态：进程已在内存中并可执行
- 阻塞态：进程已在内存中并等待一个事件
- 阻塞/挂起态：进程被挂起并等待一个事件
- 阻塞/就绪态：进程被挂起，但只要载入内存就可执行。

![Double](images/double.png)

#### 挂起的进程特点

- 该进程不能立即执行
- 该进程可能再也可能不在等待一个事件，若在等待一个事件，那么阻塞条件不依赖于挂起条件，阻塞事件的发生不会使进程立即执行。
- 为阻止该进程执行，可通过代理使其置于挂起态，代理可以是进程本身，也可以是父进程或操作系统。
- 除非代理显示地命令系统进行状态转换，否则该进程无法从这一状态转移。

#### 挂起的原因

|事件|说明|
|:--|:--|
|交换|操作系统需要释放足够的内存空间，以调入并执行处于就绪态的进程|
|其他OS原因|操作系统可能挂起后台进程或工具程序进程，或挂起可能会导致问题的进程|
|交互式用户请求|用户希望挂起一个程序的执行，以便进行调试或关联资源的使用|
|定时|进程可被周期性地执行（如记账或系统监视进程），并在等待下一个时间间隔时挂起|
|父进程请求|父进程可能会希望挂起后代进程的执行，以检查或修改挂起的进程，或协调不同后代进程之间的行为|

## 3. 进程描述

### 3.1 操作系统的控制结构

操作系统为了管理进程和资源，必须掌握每个进程和资源的当前状态，普遍采用的方法是，操作系统构造并维护其管理的每个实体的信息表。主要有4种不同类型的表：内存、I/O、文件和进程。

![OSCtrl](images/osCtrl.png)

**内存表**：用于跟踪内（实）存和外（虚）存。内存表必须包含如下信息：

- 分配给进程的内存。
- 分配给进程的外存。
- 内存或虚存块的任何保护属性，如哪些进程可以访问某些共享内存区域。
- 管理虚存所需要的任何信息。

**I/O表**：管理计算机系统中的I/O设备和通道。

**文件表**：文件表提供关于文件是否存在、文件在外存中的位置、当前状态和其他属性的信息。

**进程表**：管理进程的表，下面会详细讲。

### 3.2 进程控制结构